const functions = require("firebase-functions");
const path = require("path");
const algolia = require("./algolia");
const resizeImage = require("./resizeImage");
const {knex} = require("./mysql");
const postRender=require("./renderers/post");
const sectionRender=require("./renderers/section");
const uploader = require("./renderers/uploader");
// const sizeImage = require("./sizeImage");

const fbBucketName = functions.config().gcs.fbupload;

const {
  fbstorage,
} = require("./firebase");

// default firebase functions have 256MB memory and timeout up to 60s
// depending on the size of your uploaded images, you may need more memory or a longer timeout
// const runtimeOpts = {
//   timeoutSeconds: 540,
//   memory: "2GB",
// };

// fires on saved draft, triggers preview update
exports.createGhostDraft = functions.https.onRequest(async (req, res) => {
  const {
    body: {
      post: {
        current,
      },
    },
  } = req;

  postRender.renderUploadGhostDraft(current);

  uploader.logUpdate(current);

  res.status(200).send("draft updated");
});

// fires on saved draft, triggers preview update
exports.updateGhostDraft = functions.https.onRequest(async (req, res) => {
  const {
    body: {
      post: {
        current,
      },
    },
  } = req;

  postRender.renderUploadGhostDraft(current);

  res.status(200).send("draft updated");
});

// when post is published in ghost, renders and uploads to new post page
// rerenders the section page for each tag of the post
exports.createGhostPost = functions.https.onRequest(async (req, res) => {
  const {
    body: {
      post: {
        current,
      },
    },
  } = req;

  // render and upload post page
  await postRender.renderUploadGhostPost(current);

  // render and upload author page
  await sectionRender.renderGhostAuthorPage(current.primary_author);

  // update section pages for each tag
  current.tags.forEach(async (tag) => {
    sectionRender.renderGhostSectionPage(tag);
  });

  await algolia.indexPost(current);

  uploader.logUpdate(current);

  res.status(200).send("post created");
});

// when post is published post in ghost is updated, renders and uploads the new post page to google storage
// rerenders and uploads the section page for each tag of the post
exports.updateGhostPost = functions.https.onRequest(async (req, res) => {
  const {
    body: {
      post: {
        current,
      },
    },
  } = req;

  if (current) {
  // render post page
    await postRender.renderUploadGhostPost(current);

    await sectionRender.renderGhostAuthorPage(current.primary_author);

    // update section pages with associated tags
    current.tags.forEach((tag) => {
      sectionRender.renderGhostSectionPage(tag);
    });

    await algolia.indexPost(current);
  }

  res.status(200).send("doc updated");
});

// when post is unpublished in ghost, post page is deleted from google storage
// rerenders and uploads the section page for each tag of the post - page without the deleted article
exports.deleteGhostPost = functions.https.onRequest(async (req, res) => {
  const {
    body: {
      post: {
        current,
      },
    },
  } = req;

  const slug = current.slug;
  const id = current.id;
  const tags = current.tags;
  const path = `${slug}-${id}.html`;

  // delete article in storage
  await uploader.deletePostHtml(path);

  // update section pages with associated tags removing the article
  tags.forEach(async (tag) => {
    await sectionRender.renderGhostSectionPage(tag);
  });

  // remove from algolia index
  await algolia.deleteIndexPost(id);

  uploader.logUpdate(current);

  res.status(200).send("post deleted");
});

// gets drafts and published posts by logged in author
exports.getAuthorPosts = functions.https.onCall(async (data, context) => {
  const email = context.auth.token.email;

  const results = await knex.select("p.id", "p.title", "p.slug", "p.status")
      .from("posts as p")
      .innerJoin("posts_authors as pa", "p.id", "=", "pa.post_id")
      .innerJoin("users as u", "u.id", "=", "pa.author_id")
      .where("u.email", email)
      .orWhere("p.status", "published")
      .orWhere("p.status", "draft");

  const drafts = results.filter((d) => d.status === "draft");
  const published = results.filter((d) => d.status === "published");

  return {
    drafts,
    published,
  };
});

exports.generateSizedImages1 = functions.storage.bucket("static-times-media")
    .object()
    .onFinalize(async (object) => {
      const contentType = object.contentType; // This is the image MIME type
      const filePath=object.name;
      const fileExtension = path.extname(filePath);

      if (!contentType) {
        functions.logger.log("File has no Content-Type, no processing is required");
        return;
      }

      // filter about a second image version auto generated by ghost
      if (object.name.includes("_o-")) {
        console.log(`filtered image ${filePath}`);
        return;
      }

      // filter about a second image version auto generated by ghost
      if (object.name.includes("-author-")) {
        console.log(`filtered image ${filePath}`);
        return;
      }


      // image sizes to generate based on template breakpoints
      const imageSizes = [
        {
          name: "312",
          width: 312,
        },
        {
          name: "397",
          width: 397,
        },
        {
          name: "427",
          width: 427,
        },
        {
          name: "574",
          width: 574,
        },
        {
          name: "683",
          width: 683,
        },
        {
          name: "873",
          width: 873,
        },
        {
          name: "1173",
          width: 1173,
        },
        {
          name: "1217",
          width: 1217,
        },

      ];


      // just resize don't keep file type same
      const convertExt = fileExtension;
      // or
      // resize and convert to different file type (webp)
      // const convertExt = 'webp'

      const tasks = [];

      imageSizes.forEach((size) => {
        tasks.push(resizeImage.resizeImage({object, size, convertExt}));
      });
      const results = await Promise.all(tasks);

      const failed = results.some((result) => result.success === false);

      if (failed) {
        functions.logger.error("Failed execution of extension");
        return;
      } else {
        functions.logger.log("Completed image resizing");
      }

      return "images generated";
    });


exports.expressHandler = functions.https.onRequest(async (req, res) => {
  const fileName = req.path === "/" ? "front-page.html" : req.path.replace("/", "");

  const file = fbstorage.bucket(fbBucketName).file(fileName);
  const rs = file.createReadStream();

  const t0 = Date.now();
  res.set({
    "Cache-Control": "max-age=0, s-maxage=31536000",
    "Content-Type": "text/html; charset=utf-8",
  });
  rs.pipe(res);
  rs.on("finish", () => {
    functions.logger.log("file stream took", Date.now() - t0, "ms");
  });
  rs.on("error", (err) => {
    functions.logger.error(err);
    res.status(404).send("Not Found");
  });
});
